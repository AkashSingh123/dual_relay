use crate::{structure::guid::GuidPrefix, serialization::submessage::SubMessage, submessages::{SubmessageKind, SubmessageHeader, Data, InfoDestination, InterpreterSubmessage, InfoTimestamp, Heartbeat, EntitySubmessage, SubmessageFlag, AckNack, Gap, HeartbeatFrag, InfoReply, InfoSource, NackFrag}, messages::header::Header};
use speedy::{Readable, Writable, Endianness, Reader, Context, Writer};

#[derive(Debug)]
pub struct Message {
  header: Header,
  submessages: Vec<SubMessage>,
}

impl<'a> Message {
  pub fn deserialize_header(context: Endianness, buffer: &'a [u8]) -> Header {
    Header::read_from_buffer_with_ctx(context, buffer).unwrap()
  }

  pub fn serialize_header(self) -> Vec<u8> {
    let buffer = self.header.write_to_vec_with_ctx(Endianness::LittleEndian);
    buffer.unwrap()
  }

  pub fn add_submessage(&mut self, submessage: SubMessage) {
    self.submessages.push(submessage);
  }

  pub fn remove_submessage(mut self, index: usize) {
    self.submessages.remove(index);
  }

  pub fn submessages(self) -> Vec<SubMessage> {
    self.submessages
  }

  pub fn set_header(&mut self, header : Header){
    self.header = header;
  }
}

impl Message {
  pub fn new() -> Message {
    Message {
      header: Header::new(GuidPrefix::GUIDPREFIX_UNKNOWN),
      submessages : vec![],
      //interpteterSubmessages : vec![],
    }
  }
}

impl Default for Message {
  fn default() -> Self {
    Message::new()
  }
}

impl <C: Context> Writable<C> for Message{
  fn write_to<'a, T: ?Sized + Writer< C>>(
    &'a self,
    writer: &mut T
) -> Result<(), C::Error>{
    writer.write_value(&self.header)?;
    for x in &self.submessages{
      writer.write_value(&x)?;
    }
    Ok(())
}
}


impl <'a, C: Context> Readable<'a, C> for Message{
  fn read_from< R: Reader< 'a, C > >( reader: &mut R ) -> Result< Self, C::Error > {
    let mut message = Message::default();
    let endianess = reader.endianness();
    message.header = reader.read_value()?;
    // TODO FLAGS???
    let flag : SubmessageFlag = SubmessageFlag {
      flags : 1,
    };
    loop{
      let res : Result<SubmessageHeader, C::Error> = reader.read_value();
      let subHeader = match res {
        Ok(res) => res,
        Err(_e) => {break;},
      };
      let buffer: Vec<u8> = reader.read_vec(subHeader.submessage_length as usize)?;
    match  subHeader.submessage_id
    {
      SubmessageKind::DATA =>{
        let x = Data::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::Data(x, flag.clone())), 
          intepreterSubmessage : None 
        };
        message.add_submessage(y);
      }
      SubmessageKind::HEARTBEAT =>{
        let x = Heartbeat::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::Heartbeat(x, flag.clone())), 
          intepreterSubmessage : None
        };
        message.add_submessage(y);
      }
      SubmessageKind::GAP => {
        let x = Gap::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::Gap(x)), 
          intepreterSubmessage : None
        };
        message.add_submessage(y);
      }
      SubmessageKind::HEARTBEAT_FRAG => {
        let x = HeartbeatFrag::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::HeartbeatFrag(x)), 
          intepreterSubmessage : None
        };
        message.add_submessage(y);
      }
      SubmessageKind::ACKNACK =>{
        let x = AckNack::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::AckNack(x, flag.clone())), 
          intepreterSubmessage :None
        };
        message.add_submessage(y);
      }
      SubmessageKind::INFO_DST =>{
        let x : InfoDestination = InfoDestination::read_from_buffer_with_ctx(endianess, &buffer).unwrap();

        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : None, 
          intepreterSubmessage : Some(InterpreterSubmessage::InfoDestination(x,))
        };
        message.add_submessage(y);
      }
      SubmessageKind::INFO_TS =>{
        let x : InfoTimestamp = InfoTimestamp::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : None, 
          intepreterSubmessage : Some(InterpreterSubmessage::InfoTimestamp(x,flag.clone()))
        };
        message.add_submessage(y);
      }
      SubmessageKind::INFO_REPLY => {
        let x : InfoReply = InfoReply::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : None, 
          intepreterSubmessage : Some(InterpreterSubmessage::InfoReply(x,flag.clone()))
        };
        message.add_submessage(y);   
      }
      SubmessageKind::INFO_REPLY_IP4 => {
        todo!();
      }
      SubmessageKind::INFO_SRC => {
        let x : InfoSource = InfoSource::read_from_buffer_with_ctx(endianess, &buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : None, 
          intepreterSubmessage : Some(InterpreterSubmessage::InfoSource(x))
        };
        message.add_submessage(y); 

      }
      SubmessageKind::NACK_FRAG => {
        let x : NackFrag = NackFrag::read_from_buffer_with_ctx(endianess,&buffer).unwrap();
        let y : SubMessage = SubMessage{
          header :subHeader,
          submessage : Some(EntitySubmessage::NackFrag(x)), 
          intepreterSubmessage : None,
        };
        message.add_submessage(y); 
      }
      SubmessageKind::PAD => {
        todo!();
      }
      
      _=>{
        panic!();
      }
    }
    }
    
    Ok(message)

  }
}

#[cfg(test)]

mod tests{
  use super::*;
  use crate::speedy::{Writable, Readable};

  #[test]

  fn RTPS_message_test_shapes_demo_message_deserialization(){

    // Data message should contain Shapetype values.
    // caprured with wireshark from shapes demo.
    // packet with INFO_DST, INFO_TS, DATA, HEARTBEAT
    let bits1: Vec<u8> = vec! [
        0x52, 0x54, 0x50, 0x53, 0x02, 0x03, 0x01, 0x0f, 0x01, 0x0f, 0x99, 0x06, 0x78,
        0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x0c, 0x00, 0x01, 0x03,
        0x00, 0x0c, 0x29, 0x2d, 0x31, 0xa2, 0x28, 0x20, 0x02, 0x08, 0x09, 0x01, 0x08,
        0x00, 0x1a, 0x15, 0xf3, 0x5e, 0x00, 0xcc, 0xfb, 0x13, 0x15, 0x05, 0x2c, 0x00,
        0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x52, 0x45, 0x44, 0x00, 0x69, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00,
        0x00, 0x1e, 0x00, 0x00, 0x00, 0x07, 0x01, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00
      ];
  let rtps = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits1).unwrap();
  println!("{:?}",rtps);

  let serialized = rtps.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
  assert_eq!(bits1,serialized);

  
  }
  #[test]
  fn RTPS_message_test_shapes_demo_DataP(){
    // / caprured with wireshark from shapes demo.
    // packet with DATA(p)
  let bits2: Vec<u8> = vec! [
  0x52, 0x54, 0x50, 0x53, 0x02, 0x04, 0x01, 0x03, 0x01, 0x03, 0x00, 0x0c, 0x29,
  0x2d, 0x31, 0xa2, 0x28, 0x20, 0x02, 0x08, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc2, 0x00, 0x00, 0x00,
  0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x77, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15,
  0x00, 0x04, 0x00, 0x02, 0x04, 0x00, 0x00, 0x50, 0x00, 0x10, 0x00, 0x01, 0x03,
  0x00, 0x0c, 0x29, 0x2d, 0x31, 0xa2, 0x28, 0x20, 0x02, 0x08, 0x00, 0x00, 0x01,
  0xc1, 0x16, 0x00, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x44, 0x00, 0x04, 0x00,
  0x3f, 0x0c, 0x00, 0x00, 0x58, 0x00, 0x04, 0x00, 0x3f, 0x0c, 0x00, 0x00, 0x32,
  0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0x9f, 0xa4, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e,
  0xc9, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0x9f, 0xa4, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
  0xa8, 0x45, 0x14, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0x9f, 0xa4,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xac, 0x11, 0x00, 0x01, 0x33, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xea, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xef, 0xff, 0x00, 0x01, 0x31, 0x00, 0x18, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01, 0x48, 0x00, 0x18, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01, 0x34, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xb0, 0x04, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x08, 0x00, 0x2c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00
];

let rtps_data = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits2).unwrap();

let serialized_data = rtps_data.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
assert_eq!(bits2,serialized_data);

}

#[test]
fn RTPS_message_test_shapes_demo_info_TS_dataP(){
    // caprured with wireshark from shapes demo.
    // rtps packet with info TS and Data(p)
  let  bits1: Vec<u8> = vec! [
  0x52, 0x54, 0x50, 0x53, 0x02, 0x03, 0x01, 0x0f, 0x01, 0x0f, 0x99, 0x06, 0x78,
  0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x01, 0x08, 0x00, 0x0e, 0x15,
  0xf3, 0x5e, 0x00, 0x28, 0x74, 0xd2, 0x15, 0x05, 0xa8, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x01, 0x00, 0xc7, 0x00, 0x01, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x02,
  0x03, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x01, 0x0f, 0x00, 0x00, 0x50, 0x00,
  0x10, 0x00, 0x01, 0x0f, 0x99, 0x06, 0x78, 0x34, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0xc1, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
  0xf4, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e, 0x68, 0x31, 0x00, 0x18, 0x00, 0x01, 0x00,
  0x00, 0x00, 0xf5, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e, 0x68, 0x02, 0x00, 0x08, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x04, 0x00, 0x3f,
  0x0c, 0x3f, 0x0c, 0x62, 0x00, 0x18, 0x00, 0x14, 0x00, 0x00, 0x00, 0x66, 0x61,
  0x73, 0x74, 0x72, 0x74, 0x70, 0x73, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x69,
  0x70, 0x61, 0x6e, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00
  ];

  let  rtps = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits1).unwrap();
  println!("{:?}",rtps);

  let serialized = rtps.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
  assert_eq!(bits1,serialized);


}

#[test]
fn RTPS_message_test_shapes_demo_info_TS_AckNack(){
   // caprured with wireshark from shapes demo.
    // rtps packet with info TS three AckNacks
  let  bits1: Vec<u8> = vec! [
  0x52, 0x54, 0x50, 0x53, 0x02, 0x04, 0x01, 0x03, 0x01, 0x03, 0x00, 0x0c, 0x29,
  0x2d, 0x31, 0xa2, 0x28, 0x20, 0x02, 0x08, 0x0e, 0x01, 0x0c, 0x00, 0x01, 0x0f,
  0x99, 0x06, 0x78, 0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x03, 0x18,
  0x00, 0x00, 0x00, 0x03, 0xc7, 0x00, 0x00, 0x03, 0xc2, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06,
  0x03, 0x18, 0x00, 0x00, 0x00, 0x04, 0xc7, 0x00, 0x00, 0x04, 0xc2, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x06, 0x03, 0x18, 0x00, 0x00, 0x02, 0x00, 0xc7, 0x00, 0x02, 0x00, 0xc2,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00
];

let rtps = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits1).unwrap();
println!("{:?}",rtps);

let serialized = rtps.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
assert_eq!(bits1,serialized);




}

#[test]
fn RTPS_message_info_ts_and_dataP(){
 // caprured with wireshark from shapes demo.
// rtps packet with info TS and data(p)
    let  bits1: Vec<u8> = vec! [
    0x52, 0x54, 0x50, 0x53, 0x02, 0x03, 0x01, 0x0f, 0x01, 0x0f, 0x99, 0x06, 0x78,
    0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x01, 0x08, 0x00, 0x0e, 0x15,
    0xf3, 0x5e, 0x00, 0x28, 0x74, 0xd2, 0x15, 0x05, 0xa8, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x01, 0x00, 0xc7, 0x00, 0x01, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x02,
    0x03, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x01, 0x0f, 0x00, 0x00, 0x50, 0x00,
    0x10, 0x00, 0x01, 0x0f, 0x99, 0x06, 0x78, 0x34, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xc1, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xf4, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e, 0x68, 0x31, 0x00, 0x18, 0x00, 0x01, 0x00,
    0x00, 0x00, 0xf5, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e, 0x68, 0x02, 0x00, 0x08, 0x00,
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x04, 0x00, 0x3f,
    0x0c, 0x3f, 0x0c, 0x62, 0x00, 0x18, 0x00, 0x14, 0x00, 0x00, 0x00, 0x66, 0x61,
    0x73, 0x74, 0x72, 0x74, 0x70, 0x73, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x69,
    0x70, 0x61, 0x6e, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00
  ];
  
let rtps = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits1).unwrap();
println!("{:?}",rtps);

let serialized = rtps.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
assert_eq!(bits1,serialized);

}

  #[test]
  fn RTPS_message_infoDST_infoTS_Data_w_heartbeat(){

   // caprured with wireshark from shapes demo.
// rtps packet with InfoDST InfoTS Data(w) Heartbeat
  // This datamessage serialized payload maybe contains topic name (square) and its type (shapetype)
  // look https://www.omg.org/spec/DDSI-RTPS/2.3/PDF page 185
  let  bits1: Vec<u8> = vec! [
  0x52, 0x54, 0x50, 0x53, 0x02, 0x03, 0x01, 0x0f, 0x01, 0x0f, 0x99, 0x06, 0x78,
  0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x0c, 0x00, 0x01, 0x03,
  0x00, 0x0c, 0x29, 0x2d, 0x31, 0xa2, 0x28, 0x20, 0x02, 0x08, 0x09, 0x01, 0x08,
  0x00, 0x12, 0x15, 0xf3, 0x5e, 0x00, 0xc8, 0xa9, 0xfa, 0x15, 0x05, 0x0c, 0x01,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0xc7, 0x00, 0x00, 0x03, 0xc2, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x2f, 0x00,
  0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf5, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x50, 0x8e, 0x68,
  0x50, 0x00, 0x10, 0x00, 0x01, 0x0f, 0x99, 0x06, 0x78, 0x34, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc1, 0x05, 0x00, 0x0c, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x53, 0x71, 0x75, 0x61, 0x72, 0x65, 0x00, 0x00, 0x07, 0x00, 0x10,
  0x00, 0x0a, 0x00, 0x00, 0x00, 0x53, 0x68, 0x61, 0x70, 0x65, 0x54, 0x79, 0x70,
  0x65, 0x00, 0x00, 0x00, 0x70, 0x00, 0x10, 0x00, 0x01, 0x0f, 0x99, 0x06, 0x78,
  0x34, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x5a, 0x00,
  0x10, 0x00, 0x01, 0x0f, 0x99, 0x06, 0x78, 0x34, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x02, 0x60, 0x00, 0x04, 0x00, 0x5f, 0x01, 0x00, 0x00,
  0x15, 0x00, 0x04, 0x00, 0x02, 0x03, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0x01,
  0x0f, 0x00, 0x00, 0x1d, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00,
  0x08, 0x00, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x27, 0x00, 0x08,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x0c, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x1a,
  0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x99,
  0x99, 0x19, 0x2b, 0x00, 0x08, 0x00, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff,
  0xff, 0x1f, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x01, 0x1c, 0x00, 0x00,
  0x00, 0x03, 0xc7, 0x00, 0x00, 0x03, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00
  ];

  let rtps = Message::read_from_buffer_with_ctx(Endianness::LittleEndian,&bits1).unwrap();
  println!("{:?}",rtps);

  let entitySubmessage = rtps.submessages[2].submessage.as_ref().unwrap();
  let dataSubmessage = entitySubmessage.get_data_submessage().unwrap();
  let serializedPayload = dataSubmessage.serialized_payload.value.clone();
  println!();
  println!();
  println!("{:x?}", serializedPayload);

  let serialized = rtps.write_to_vec_with_ctx(Endianness::LittleEndian).unwrap();
  assert_eq!(bits1,serialized);

  }

}